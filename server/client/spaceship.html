<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MayukhVerse - Cinematic Starship</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, ship, stars, clock;

        // Custom Shader for the Neon Pulse effect seen in your image
        const neonShader = {
            uniforms: {
                uTime: { value: 0 },
                uColor: { value: new THREE.Color(0x3bc4ff) }
            },
            vertexShader: `
                varying vec3 vPosition;
                void main() {
                    vPosition = position;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float uTime;
                uniform vec3 uColor;
                varying vec3 vPosition;
                void main() {
                    // Create a scan-line pulse effect
                    float pulse = sin(vPosition.z * 10.0 + uTime * 5.0) * 0.5 + 0.5;
                    gl_FragColor = vec4(uColor * (0.8 + pulse * 0.4), 1.0);
                }
            `
        };

        function init() {
            scene = new THREE.Scene();
            clock = new THREE.Clock();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 8);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // 1. DYNAMIC STARFIELD (Cinematic Warp)
            const starGeo = new THREE.BufferGeometry();
            const posArray = new Float32Array(8000 * 3);
            for(let i = 0; i < 8000 * 3; i++) posArray[i] = (Math.random() - 0.5) * 150;
            starGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            stars = new THREE.Points(starGeo, new THREE.PointsMaterial({ color: 0xffffff, size: 0.05 }));
            scene.add(stars);

            // 2. THE SPACESHIP (Matching your reference image silhouette)
            const shipGroup = new THREE.Group();
            const shipMaterial = new THREE.ShaderMaterial({
                uniforms: neonShader.uniforms,
                vertexShader: neonShader.vertexShader,
                fragmentShader: neonShader.fragmentShader,
                wireframe: true
            });

            // Main Hull
            const hullGeo = new THREE.CylinderGeometry(0.2, 0.8, 4, 8);
            const hull = new THREE.Mesh(hullGeo, shipMaterial);
            hull.rotation.x = Math.PI / 2;
            shipGroup.add(hull);

            // Large Engines (Back left/right)
            const engineGeo = new THREE.CylinderGeometry(0.4, 0.4, 1.5, 8);
            const engL = new THREE.Mesh(engineGeo, shipMaterial);
            engL.position.set(-0.8, 0, 1.5);
            engL.rotation.x = Math.PI / 2;
            shipGroup.add(engL);

            const engR = engL.clone();
            engR.position.x = 0.8;
            shipGroup.add(engR);

            // Wings
            const wingGeo = new THREE.BoxGeometry(5, 0.1, 1.5);
            const wings = new THREE.Mesh(wingGeo, shipMaterial);
            wings.position.z = 0.5;
            shipGroup.add(wings);

            ship = shipGroup;
            scene.add(ship);

            // 3. ENGINE EXHAUST (The glowing flares in your image)
            const exhaustGeo = new THREE.ConeGeometry(0.3, 2, 16);
            const exhaustMat = new THREE.MeshBasicMaterial({ color: 0x3bc4ff, transparent: true, opacity: 0.6 });
            
            const flareL = new THREE.Mesh(exhaustGeo, exhaustMat);
            flareL.position.set(-0.8, 0, 3.2);
            flareL.rotation.x = -Math.PI / 2;
            ship.add(flareL);

            const flareR = flareL.clone();
            flareR.position.x = 0.8;
            ship.add(flareR);

            animate();
        }

        function animate() {
            requestAnimationFrame(animate);
            const elapsed = clock.getElapsedTime();
            neonShader.uniforms.uTime.value = elapsed;

            // --- CINEMATIC MOTION (Organic Float) ---
            ship.position.y = Math.sin(elapsed * 1.5) * 0.3;
            ship.position.x = Math.cos(elapsed * 0.8) * 0.5;
            
            // Banking (leaning into turns)
            ship.rotation.z = Math.sin(elapsed * 0.8) * 0.4;
            ship.rotation.y = Math.cos(elapsed * 0.5) * 0.1;

            // --- STAR WARP SPEED ---
            const positions = stars.geometry.attributes.position.array;
            for(let i = 2; i < positions.length; i += 3) {
                positions[i] += 1.2; // Move stars toward camera
                if (positions[i] > 10) positions[i] = -100; // Reset star to horizon
            }
            stars.geometry.attributes.position.needsUpdate = true;

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        init();
    </script>
</body>
</html>